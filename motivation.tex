%!TEX root = paper.tex

\section{Common Practice}
\label{sec:motivation}

\paragraph{Meta-build Systems}
{\it Meta-build systems} such as Contractor, WAF, and
MixDown~\cite{amundson:contractor,epperly+:mixdown,epperly+:mixdown-report,nagy:waf} are
related to package managers, but they focus on ensuring that a single
package builds correctly with its dependencies.  MixDown notably provides excellent
features for ensuring consistent compiler flags in a build.
However, these systems do not provide facilities to manage
large package repositories or combinatoric versioning.

\paragraph{Traditional package managers}
Package managers automate the installation of complex sets of software packages.
{\it Binary package managers} such as RPM, yum, and  
APT~\cite{foster+:rpm03,silva:apt01,yum} are integrated with most
OS distributions, and they are used to ensure that dependencies
are installed before packages that require them.
These tools largely solve the problem of managing a {\it single} software
stack, which works well for the baseline OS and drivers, which are 
common to all applications on a system.
These tools assume that each package only has a single version
and most of the tools install packages in a single, inflexible location.
To install multiple configurations, the user must create a custom, combinatoric
naming scheme to avoid conflicts. They typically require root 
privileges and do not optimize for specific hardware.

{\it Port systems} such as Gentoo, BSD Ports, MacPorts, and 
Homebrew~\cite{bsdports,groffen:gentoo-prefix,homebrew,macports,thiruvathukal:gentoo04}
build packages from source instead of installing from a pre-built binary.
Most existing port systems suffer from 
the same versioning and naming issues as traditional package managers.
Some allow multiple versions to be installed in the same
prefix~\cite{groffen:gentoo-prefix}, but again the burden is on package
creators to manage conflicts. This burden effectively restricts installations 
to few configurations.


\paragraph{Virtual Machines and Containers}

Packaging problems arise in HPC because a supercomputer's hardware, OS, and
filesystem are shared by many users with different requirements.  The classic 
solution to this problem is to use virtual
machines (VMs)~\cite{barham2003xen,rosenblum1999vmware,smith2005architecture}
or lightweight virtualization techniques like Linux 
containers~\cite{felter2014updated,merkel2014docker}. This model allows each
 user to have a personalized environment with its own package manager, and it 
has been extremely successful for servers at cloud data centers. VMs typically
have near-native compute performance but low-level HPC network drivers still 
exhibit major performance issues. VMs are not well supported on many
non-Linux operating systems, an issue for the lightweight 
kernels of bleeding-edge Blue Gene/Q and Cray machines. Security
is another major concern: a profusion of VMs makes mandatory patching
difficult when user's environments differ significantly from those of 
the facility. Perhaps most importantly, significant differences in
versioning leaves the majority of the installation burden on end users.

\begin{table*}\centering
\begin{tabular}{|l|l|}
\hline
Site           & Naming Convention \\
\hline
\hline
LLNL       & {\tt / usr / global / tools / \$arch / \$package / \$version} \\
           & {\tt / usr / local~ / tools / \$package-\$compiler-\$build-\$version } \\
\hline
Oak Ridge~\cite{jones+:cug08}  & {\tt / \$arch / \$package / \$version / \$build} \\
\hline
TACC/Lmod~\cite{mclay:lmod-tutorial}& {\tt / \$compiler-\$comp\_version / \$mpi / \$mpi\_version / \$package / \$version} \\
\hline
\hline
Spack default                  & {\tt / \$arch / \$compiler-\$comp\_version / \$package-\$version-\$options-\$hash} \\
\hline
\end{tabular}
\caption{
	Software organization of various HPC sites.
	\label{tab:naming-conventions}
}
\end{table*}

\paragraph{Manual and Semi-automated Installation}

To cope with software diversity, many HPC sites use a combination of existing
packages managers and either manual or semi-automated software installation.  
For the baseline OS, many sites maintain traditional binary
packages using the vendor's package manager. LLNL maintains a Linux 
distribution, CHAOS~\cite{chaos} for this purpose.

For more specific builds, many sites adhere to detailed naming conventions
that encode information in file system paths. 
Table~\ref{tab:naming-conventions} shows a sampling of conventions
at several sites. At LLNL, we use the APT package manager for installs 
in the {\tt /usr/local/tools} file system; we use {\tt /usr/global/tools} 
for manual installs.
ORNL uses hand installs but adheres to a strict scripting structure
that can be used to reproduce each build~\cite{jones+:cug08}.
TACC relies heavily on locally maintained RPMs for its software installs.

From the conventions in Table~\ref{tab:naming-conventions},
we see that most sites use some combination of architecture, compiler version,
package name, package version, and a custom (up to the author, sometimes
encoded) build identifier.  TACC and many other sites also explicitly
include the MPI version in the path. MPI is explicitly called out
because it is one of the most common software packages for HPC.
However, it is only one of many dependencies that go into a build.
None of these naming conventions covers the entire configuration
space, and none has a way to represent, e.g., two builds that are identical
save for the version of a particular dependency library.  In our experience
at LLNL, naming conventions like these have not succeeded because the full
set of users want more configurations than we can represent with a practical
directory hierarchy. Staff frequently install nonconforming packages 
in nonstandard locations with ambiguous names.

\paragraph{Environment Modules and RPATHs}

Diverse software versions not only present problems for build and installation;
they also complicate the runtime environment. When launched, an executable
must determine the location of its dependency libraries, or it will not run.
Statically linked binaries do not have this issue, but modern
operating systems make extensive use of dynamic linking.
By default, the dynamic loader on most systems is configured to search only
system library paths such as {\tt /lib}, {\tt /usr/lib}, and
{\tt /usr/local/lib}.  If binaries are installed in other locations, the
{\it user} who runs the program (often not the user or staff member who
installed the binary) must typically add dependency library paths to
{\tt LD\_LIBRARY\_PATH} (or a similar environment variable) so that the loader
can find them.

Many HPC sites address this problem using {\it environment modules}, which 
allow users to ``load'' and ``unload'' such settings dynamically using simple 
commands. Environment emerged in 1991, and there are many implementations 
available~\cite{dotkit,furlani+:lisa91,furlani+:lisa96,mclay:lmod,mclay:lmod-tutorial}.
The most advanced implementations, such as Lmod~\cite{mclay:lmod,mclay:lmod-tutorial},
provide software hierarchies similar to the naming conventions in 
Table~\ref{tab:naming-conventions}. They allow users to load a software stack
quickly if they know which one is required.

The alternative to per-user environment settings is to embed library search 
paths in installed binaries at compile time. When set this way, the search 
path is called an {\tt RPATH}. {\tt RPATHs} and environment modules are not 
mutually exclusive. Modules can still be used to set {\tt MANPATH}, {\tt PATH}
and variables, but adding {\tt RPATHs} ensures that binaries run correctly 
regardless of whether the right module is loaded. LC installs software with 
both {\tt RPATHs} and {\tt dotkit}~\cite{dotkit} modules.

\paragraph{Modern Package Managers}

Recently, a number of package managers have been developed to manage 
multi-configuration builds.
%
Nix~\cite{dolstra+:icfp08,dolstra+:lisa04}
is a package manager and an OS distribution that supports the installation of
arbitrarily many software configurations.  As at most HPC sites, each package
in Nix is installed in a unique prefix, but Nix does not have a human-readable
naming convention.  Instead, Nix determines the prefix by hashing the package
file along with its dependencies.

Hashdist~\cite{hashdist} is a meta-build system and package manager for HPC.
Like Nix, it uses cryptographic versioning, and it archives installations
in a git repository so that they can be recalled on demand. 
%
Both Nix and hashdist use {\tt RPATHs} in their packages to ensure that
libraries are found correctly. 

The EasyBuild~\cite{hoste+:pyhpc12} tool is in production use at
the University of Ghent.  It allows multiple versions to be installed
at once.  Rather than setting {\tt RPATHs}, it auto-generates module files
to manage each package's environment, and it is closely coupled with 
Lmod~\cite{geimer+:hust14}.  EasyBuild groups the compiler, MPI, FFT, and
BLAS libraries together in a {\it toolchain} that can be combined with
any package file. This provides some degree of composability and
separates compiler flags and MPI concerns from client packages.

Smithy~\cite{digirolamo:smithy} is a similar tool in use at ORNL. It
can generate module files, but it does not provide any 
automated dependency management; it only checks whether a package's
prerequisites have already been installed by the user.

\paragraph{Gaps in current common practice}
The cryptographic versioning of Nix and Hashdist is very flexible. It versions
the package {\it and} its dependency configuration, and can represent any
configuration. However, users cannot navigate or query the installed software.
The systems are in a sense ``write-only'':
Nix does not even offer a way to ask for a package's dependencies.
%
EasyBuild and Smithy generate environment modules, which allow querying
through their own interface. Naming in existing module systems, however, cannot
handle combinatoric versions. The Lmod authors call this the
``matrix problem``~\cite{mclay:lmod-tutorial}.

%EasyBuild's attempts to version groups dependencies by adding versions to
%toolchains, but the naming is difficult to understand.
%. Compiler, MPI, and 
%some library versions are lumped together, but the results is cryptic, e.g.
%{\tt goolf} stands for ``gcc, openmpi, openblas, ScaLAPACK, FFTW'', and
%its version is meaningless.

%Existing tools do not enforce {\tt RPATHs}, leaving them to package authors.
%This may lead to erroneous runs.

The main limitation of existing tools is the lack of build {\it composability}.
The full set of package versions is combinatoric, and realizing an arbitrary
combination of compiler, MPI version, build options, and dependency versions
requires tediously modifying many package files.
%
Indeed, the number of package files required for existing systems scales with
the number of version {\it combinations}, not the number of packages, which.
quickly becomes unmanageable.  As an example, the very flexible EasyBuild
system has over 3,300 files for several permutations of only 600 packages. 
Other systems have similar issues. HPC sites need a mechanism to 
{\it parameterize} packages so that new builds can be {\it composed} on the fly.











