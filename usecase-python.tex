%!TEX root = paper.tex

\subsection{Support for interpreted languages}
\label{sec:usecase-python}

Python is becoming increasingly popular for HPC applications, 
due to its flexibility as a language and due to its excellent support
calling into compiled numerical libraries for enhanced performance.
Even though Python is an interpreted language, it is frequently used
as a friendlier interface to compiled libraries like FFTW, ATLAS, and
other linear libraries.  This is how many LLNL code teams use Python.
%
LC supports Python installations for several application teams,
and maintenance of these repositories has grown increasingly complex over
time.  The problems are similar to those that drove us to create
Spack: different teams want different Python libraries with many different
configurations.

Existing Python package managers are either language-specific like 
{\tt easy\_install}~\cite{eby:setuptools}, 
or they do not effectively support building from source~\cite{anaconda,conda}, let
alone multi-configuration builds like Spack's.  More glaringly, the default
model for Python extensions is to install them {\it directly} into the Python
interpreter's prefix, but this makes having multiple versions installed impossible.
The alternate way to install Python extensions is to install them in their own prefix,
but in this mode users must manually add each package to their {\tt PYTHONPATH}. 
We wanted a way to  easily manage many different versions and {\it also} allow teams
to have a baseline set of Python packages available by default in every instance.

To support this mode of operation, we added the concept of {\tt extension} packages
to Spack. Python modules now use the {\tt extends('python')} directive instead of
{\tt depends\_on('python')}, and they install into their own prefix like any other
package.  However, we added the capability to {\tt activate} or {\tt deactivate} an
extension within the Python extension it depends on.  When this happens, each file
in the extension prefix is symbolically linked into Python's prefix, as though it were
installed wihin the Python instance. The activate command notifies the user and
fails to activate if any file conflict would arise from this operation.
Deactivating removes the symbolic links and restores the Python installation to its 
pristine state. 

There were additional complications because many Python packages {\it install their own
package manager} if they do not find {\tt easy\_install} in the Python installation.
There are also no fewer than three ways that Python package add themselves to the
interpreter's default path, and some of them conflict. We modified Spack so that 
extendable packages like Python can supply custom code in their package file that is
run on activation and deactivation to handle any necessary language-specific tasks.
Python uses this to merge conflicting files generated by the {\tt easy\_install} tool.

The end result is that Python extensions can now be installed automatically
in their own prefixes, and they but they can be composed with a wide range
of bleeding-edge libraries that other package managers do not handle.  To experiment
with these extensions, users can load environment modules generated by Spack.
If they want a particular version to be available without any special environment 
settings, they can activate it within the Python instance.

Spack now essentially implements a ``meta package-manager'' for each Python
instance, and it can live together with Spack's normal installation model.
This has allowed us to efficiently support our application teams, for whom we can
now rapidly construct custom Python installations.  We have also reduced
the amount of time LLNL staff spend installing Python modules.
Because Spack packages can extend the activation and deactivation mechanisms,
we believe the same mechanism could be used with other 
interpreted languages that have similar extension models, such as R, Ruby, or Lua.

