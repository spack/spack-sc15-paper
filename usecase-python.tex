%!TEX root = paper.tex

\subsection{Support for interpreted languages}
\label{sec:usecase-python}

Python is becoming increasingly popular for HPC applications, 
due to its flexibility as a language and its excellent support
for calling into fast, compiled numerical libraries.
Python is an interpreted language, but one can use it
as a friendlier interface to compiled libraries like FFTW, ATLAS, and
other linear algebra libraries.  Many LLNL code teams use Python in this manner.
%
LC supports Python installations for several application teams,
and maintenance of these repositories has grown increasingly complex over
time.  The problems are similar to those that drove us to create
Spack: different teams want different Python libraries with different
configurations.

Existing Python package managers are either language-specific like 
{\tt easy\_install}~\cite{eby:setuptools}, 
or they do not effectively support building from source~\cite{anaconda,conda}, let
alone multi-configuration builds like Spack's.  More glaringly, the default
model for Python extensions is to install them {\it directly} into the Python
interpreter's prefix, but this makes it impossible to install multiple versions.
An alternative is to install Python extensions in their own prefix,
but then users must manually add each package to their {\tt PYTHONPATH}. 
We wanted a way to  easily manage many different versions and {\it also} allow teams
to have a baseline set of Python packages available by default.

To support this mode of operation, we added the concept of {\tt extension} packages
to Spack. Python modules now use the {\tt extends('python')} directive instead of
{\tt depends\_on('python')}.
Each module installs into its own prefix like any other package,
and each module depends on a particular Python installation.
Additionally, we added the capability to {\tt activate} and {\tt deactivate} an
extension within its dependent Python installation.  When this happens, each file
in the module prefix is symbolically linked into the Python installation prefix, as though it were
directly installed within the Python instance. If any file conflict would arise from this operation,
the activate operation fails and notifies the user.
The deactivate operation removes the symbolic links and restores the Python installation to its 
pristine state. 

There were additional complications because many Python packages {\it install their own
package manager} if they do not find {\tt easy\_install} in the Python installation.
There are also no fewer than three ways that Python packages add themselves to the
interpreter's default path, and some of these conflict. We modified Spack so that 
extendable packages, like Python, can supply custom code in their package file that is
executed during activation and deactivation to handle any necessary language-specific tasks.
Python uses this feature to merge conflicting files that are generated by the {\tt easy\_install} tool.

The end result is that Python extensions can now be installed automatically
in their own prefixes, but they can be composed with a wide range
of bleeding-edge libraries that other package managers do not handle.  To experiment
with these extensions, users can load environment modules generated by Spack.
If they want a particular version to be available without any special environment 
settings, they can activate it within the Python instance.

Spack now essentially implements a ``meta package-manager'' for each Python
instance, and it can live together with Spack's normal installation model.
This has allowed us to efficiently support our application teams, for whom we can
now rapidly construct custom Python installations.  We have also reduced
the amount of time that LC staff spend installing Python modules.
Because Spack packages can extend the activation and deactivation mechanisms,
we believe the same mechanism could be used with other 
interpreted languages with similar extension models, such as R, Ruby, or Lua.

