%!TEX root = paper.tex

%\begin{figure}
%\includegraphics[width=\columnwidth]{figs/spack-find-output.pdf}
%\end{figure}

\section{The Spack Package Manager}
\label{sec:implementation}

We have developed {\it Spack}, the Supercomputing PACKage manager, based on our
software needs Lawrence Livermore National Laboratory.
Spack solves the software matrix problem by allowing {\it parametric} builds.
Each package in Spack is parameterized by its name, version, architecture, compiler, 
compiler version, build options, and by its dependencies.
Like other systems, Spack allows multiple build variants to be installed at once,
but it provides novel, recursive {\it spec} syntax.  Specs are concise
expressions for partially constrained software dependence graphs. The same
spec syntax can be used on the command line to request new build 
configurations, or to query installed packages over many dimensions.

Spack borrows ideas from Nix to support multiple installations with 
cryptographic hashes, but it goes further and provides a build environment
that takes many burdens off of the package writer.  In particular, Spack uses
compiler wrappers to automatically add {\tt RPATHs} for {\it all} dependencies
to installed binaries, so that package authors do not have to.  Compiler
wrappers also give the packager more control over the build: package authors
can more easily port to new platforms by filtering compiler flags.

\subsection{Spack Specs}
	\todo{1 page}

%\begin{figure}
%\begin{grammar}
%  <spec-list> ::= \{ <spec> [ <dep-list> ] \}
%  
%  <dep-list>  ::= \{ `\textsf \textasciicircum' <spec> \}
%
%  <spec>      ::= <id> [ options ]
%  
%  <options>   ::= \{ `@' version-list | `+' <variant> \newline
%                  | `-' <variant> ~~~| `~' <variant> \newline
%                  | `\%' <compiler> ~| `=' <architecture> \}
%                  
%  <variant>      ::= <id>
%
%  <architecture> ::= <id>
%
%  <compiler>     ::= <id> [ <version-list> ]
%
%  <version-list> ::= <version> [ \{ `,' version \} ]
%
%  <version>      ::= <id> | <id> `:' | `:' <id> | <id> `:' <id>
%
%  <id>           ::= [A-Za-z0-9_][A-Za-z0-9_.-]*  
%
%\end{grammar}
%\end{figure}


\subsection{Versioned Virtual Dependencies}
	\todo{.5 page}

\subsection{Abstract \& Concrete Specs}
	\todo{.75 page}
	
\subsection{Install Environment}

\subsubsection{Compiler Wrappers \& RPATHs}
	\todo{.5 page}

\subsubsection{Potential for auto-generation of modules (with deps)}
	\todo{.5 page}

\begin{verbatim}
module disadvantages:
	- lmod solves a lot of problems
	- not on all systems
		- users often run from just a path.
		- not guaranteed that LD_LIBRARY_PATH, etc will
		  be set correctly.

- Lmod assumes build & submit environment must match
	- users often have NO IDEA what environment a package
	  was built with
	- multiple apps may be built with different stacks
	- combining them in a workflow is difficult with modules
		(need to know right incantation)

	- TACC implements a rather complicated mapping back to
	    the build env (Lmod CheckExec)
	

- Spack solves the matrix problem mentioned in the Lmod
    presentation (slide 98)
	- hierarchy is nasty -- every branch represents a
	  greedy choice
	- might NEED a specific version of ONE dependency
	  that is not supported in the tree
	  => SPACK!

- libmesh
	- boost, petsc, trilinos, grvy, etc.
\end{verbatim}
