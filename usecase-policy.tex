%!TEX root = paper.tex

\subsection{User and Site Policies}
\label{sec:usecase-policy}

Spack makes it easy for package maintainers to create and organize package installations.  But it also needs to be easy for end-users to find and use those packages.  Different end-users may have different expectations about how packages should be built and installed, and those expectations are typically shaped by years of site policies, personal preferences, and lingering legacy decisions originallly made on a DEC VAX.  Rather than try to dictate these expectations, Spack allows both end-users and package maintainers to create custom policies dictating how packages are built and installed at their site.

\subsection{Package Views}
\label{sec:package-views}

While Spack can easily create a dozen installations of a package like MPILeaks across different compilers and MPI implementations, it can be difficult for an end-user to determine which of those dozen packages should be used with their application.  As discussed in Section~\ref{sec:envmodule}, environment modules are commonly used on supercomputer systems to solve this problem, and Spack allows the package administrator to automatically create module and dotkit files for packages Spack installs.

However, even when modules and dotkits are available many users will go directly through the filesystem to access package installs.  Spack installs packages into paths based on concretized specs, which is ideal for maintaining multiple package installations, but may be difficult for an end-user to navigate.  A version of MPILeaks, for example, may be installed in a location like {\tt spack/opt/chaos\_5\_x86\_64\_ib/ gcc@4.9.2/mpileaks@1.0-db465029}.

Spack thus allows the creation of views, which are a symlink-based directory layout of packages.  Views provide a human-readable directory layout, which can be taylored to fit alongside existing directory layouts or used to create new layouts.  For example, the above MPILeaks package may have a view that creates a symlink in {\tt /opt/mpileaks-1.0-openmpi} to the spack installation of MPILeaks.  The same package install may be referenced by multiple symlinks and views, so the above package could also be symlinked from a more generic {\tt /opt/mpileaks-openmpi} symlink (which is useful for users who don't want to hardcode towards a specific version).  Views can also be used to create symlinks to specific executables or libraries in an install, so a spack-built gcc 4.9.2 install may have a view that creates symlinks from {\tt /bin/gcc49} and {\tt /bin/g++49} to the appropriate {\tt gcc} and {\tt g++} executables.

Views are configured through a spackconfig file, which can be setup at a site-wide level or for individual users.  For each package or set of packages, the spackconfig file contains rules describing the symlinks that should point into that package.  The symlink names can be parameterized.  For example, the above MPILeaks symlink might have been created by {\tt /opt/\$\{PACKAGE\}-\$\{VERSION\}-\$\{MPINAME\} } rule.  When spack installs or removes packages, symlinks are automaticaly created, deleted, or updated according to the rules.  

Spack's views are a projection from a point in a high-dimension space (the concretized spec, which will have all parameters fully specified) to point in a lower-dimension space (the symlink name, which may only specify a few parameters).  Thus several package installations may map to the same symlink.  For example, the above MPILeaks symlink could point to an MPIleaks compiled with gcc or icc--the compiler parameter is not part of the symlink.  To keep  package installations  consistent and reproducible, Spack has a well-defined mechanism for resolving conflicting symlinks.  Spack defines a sort order for packages, which arranges packages from ``most desired'' to ``least desired''.  When a symlink could resolve to multiple package installations, Spack points the symlink at the most desired package.  

By default, Spack treats newer versions of packages compiled with newer compilers as more desirable than older packages built with older compilers.  It has well-defined, but not necessarily meaningful, preferences for deciding between MPI implementations and different compilers.  A user can override Spack's default sort order through their spackconfig file.  For example, at one site users may typically use the intel compiler, but some users also use system's default gcc 4.4.7.  These preferences could be stated by adding the line {\tt compiler\_order = icc,gcc@4.4.7} to the site's spackconfig file, which would cause the ambigious MPILeaks symlink to point to an ICC installation.  Any compiler left out of the compiler\_order setting is treated as less prefered than explicitly stated compilers.  Spack can also be configured to treat specific package versions as more prefered than other versions, which can be useful if a new version is unstable and untested, and should not be advertised with symlinks.  


\subsection{Package Configurations}

It is also useful to specify site-specific options for how packages should be built.  The correct configure line for building packages may be different across sites.  For example, the Spindle tool can have logging locations and security policies specified on its configure line.  Spack can make reasonable guesses about Spindle's proper configure line, but it cannot create a customized installation for the site.  One way to solve this would be to edit the Spindle package description in Spack and manually change how configure is invoked.  This is not ideal, as the Spindle package description is part of the Spack source code, and modifying it makes it difficult to share spack versions and updates across sites.

Instead Spack allows the creation of site-specific variants of packages.  The build instructions for a spack package are encoded in a Python class, which must inherit from Spack's {\tt Package} class.  Via the spackconfig file, users can specify additional search directories for finding additional {\tt Package} classes.  These additional packages can inherit from and replace the Spack's default packages, allowing sites to either tweak or completely replace Spack's build recipes.  To continue the previous example, a site can write a {\tt LocalSpindle} Python class, which inherits from Spack's {\tt Spindle} class.  {\tt LocalSpindle} may simply add additional configure flags to the {\tt Spindle} class, while leaving the dependencies and most of the build instructions from its parent class.  To keep builds deterministic and reproducable, Spack also tracks which {\tt Package} class drove a specific build. 
